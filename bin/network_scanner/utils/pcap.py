# -*- coding: utf-8 -*-
# 
# Script : network_scanner/utils/pcap.py
# Author : Hoon
#
# ====================== Comments ======================
#  

# Python Libraries
import os, sys
from ctypes import cdll
from ctypes import c_ushort, c_ubyte, c_uint16, c_int, c_char_p, c_void_p, c_long
from ctypes import Structure, POINTER
from ctypes import create_string_buffer, byref, cast
from socket import AF_INET, inet_ntoa

from os      import environ
from os.path import join   as path_join
from os.path import exists as path_exists

# Module Libraries
from const.default import WIN32, ENCODING

_lib = None

##############################################################################################################################################################################
# windows의 경우 pcap설치 경로 지정
##############################################################################################################################################################################
if WIN32:          
    pcap_dll_paths = [
          os.environ[ 'WINDIR' ] + "\\System32\\Npcap"
        , os.environ[ 'WINDIR' ] + "\\System32"
    ]

    ###################################################################################################################################################
    # npcap 설치 경로에서 wpcap.dll파일과 packet.dll파일을 찾아 %PATH%에 추가하고 wpcap.dll 라이브러리 로딩
    ###################################################################################################################################################
    for pcap_dll_path in pcap_dll_paths:
        
        #################################################################################################################################
        # wpcap.dll파일 지정
        #################################################################################################################################
        wpcap_dll = os.path.join( pcap_dll_path, 'wpcap.dll' )
        
        #################################################################################################################################
        # packet.dll파일 지정
        #################################################################################################################################
        packet_dll = os.path.join( pcap_dll_path, 'Packet.dll' )
        
        #################################################################################################################################
        # wpcap_dll 및 packet.dll파일 존재 여부 확인
        #################################################################################################################################
        if  os.path.exists( wpcap_dll  )\
        and os.path.exists( packet_dll ):
            
            #####################################################################################################
            # 두 파일 존재 경우 'PATH'에 추가
            #####################################################################################################
            os.environ[ 'PATH' ] = f"{ pcap_dll_path };{ os.environ[ 'PATH' ] }"
            _lib                 = cdll.LoadLibrary( wpcap_dll )
            break

##############################################################################################################################################################################
# linux의 경우 pcap설치 경로 지정
##############################################################################################################################################################################
else:
    libpcap_so_paths = [
          '/usr/lib64/libpcap.so.1'
        , '/usr/lib64/libpcap.so'
        , '/usr/lib/libpcap.so.1'
        , '/usr/lib/libpcap.so'
    ]
    
    ###################################################################################################################################################
    # npcap 설치 경로에서 libpcap.so.1파일과 libpcap.so파일을 찾아 라이브러리 import
    ###################################################################################################################################################
    for libpcap_so_path in libpcap_so_paths:
        if os.path.exists( libpcap_so_path ):
            _lib = cdll.LoadLibrary( libpcap_so_path )
            break

##############################################################################################################################################################################
# npcap 미설치의 경우 에러 발생
##############################################################################################################################################################################
if _lib == None:
    
    if WIN32: sys.exit( 'NOT_INSTALLED_PCAP_DRIVER' )
    else    : sys.exit( 'NOT_INSTALLED_LIBPCAP'     )


##############################################################################################################################################################################
# pcap 라이브러리 사용을 위한 클래스
# scapy/libs/structures.py
##############################################################################################################################################################################
class bpf_insn( Structure ):
    _fields_ = [
          ( "code", c_ushort )
        , ( "jt"  , c_ubyte  )
        , ( "jf"  , c_ubyte  )
        , ( "k"   , c_int    )
    ]


class bpf_program( Structure ):
    _fields_ = [
          ( 'bf_len'  , c_int               )
        , ( 'bf_insns', POINTER( bpf_insn ) )
    ]

##############################################################################################################################################################################
# pcap 라이브러리 사용을 위한 클래스
# scapy/libs/winpcapy.py
##############################################################################################################################################################################

##############################################################################################################################################################################
# sockaddr 구조체
#   소켓 주소를 표현하는 구조체.
#   원래 소켓 자체가 TCP/IP만을 목적으로 만들어진 것이 아니어서, 다양한 주소 체계에 맞게 범용 목적으로 사용하기 위해 이런 구조를 가지고 있다.

# struct sockaddr {
#     sa_family_t sa_family    ;  // 소켓의 주소체계. PF_INET= IPv4 주소체계.
#     char        sa_data[ 14 ];  // 해당 주소체계에서 사용하는 주소 정보. ip주소와 포트가 담긴다.
#                                    sa_data의 뒷부분에 8바이트 공간이 남는데,
#                                    이는 sockaddr이 TCP/IP(TCP,UDP) 뿐 아니라 다른 프로토콜에서도 사용하기 위한 구조체이기 때문
#                                    프로토콜마다 들어갈 주소체계와 내용이 다르기 때문에 sa_data의 크기가 14바이트로 잡혀있는 것
# }
##############################################################################################################################################################################
class sockaddr( Structure ):
    _fields_ = [
          ( "sa_family", c_ushort     )     # 소켓의 주소체계. PF_INET= IPv4 주소체계.
        , ( "sa_data"  , c_ubyte * 14 )     # 해당 주소체계에서 사용하는 주소 정보.
    ]

##############################################################################################################################################################################
# sockaddr_in 구조체
#   위에서 정의된 sockaddr 구조체에서 sa_family가 AF_INET인 경우에 사용하는 구조체

#   IPv4 주소체계에서 사용하는 구조체. 
#   소켓 프로그램은 범용 주소 구조체로 sockaddr을 사용, 
#   그러나 주소체계의 종류에 따라 별도의 전용 구조체를 만들어 사용하는게 아무래도 편리. 
  
#   Local Unix 주소 체계는 sockaddr_un 구조체를 사용. 
  
#   소켓라이브러리는 sockaddr을 사용하므로 라이브러리에 주소 정보를 넘길 때는 sockaddr로 형변환을 하여 넘긴다. 
#   그러므로 당연히 구조체의 크기는 동일하다. 
#   아래 세부 구조를 살펴보자.

# struct sockaddr_in{
#     sin_family_t sin_family      ;    // IPv4 주소체계에서 사용하므로 항상 AF_INET으로 설정
#     unist16_t    sin_port        ;    // 포트 번호
#     struct       in_addr sin_addr;    // IP주소를 나타내는 32비트 정수 타입 구조체
#     char         sin_zero[ 8 ]   ;    // sockaddr과 같은 크기를 유지하기 위해 필요한 패딩( padding ) 공간. 항상 0.
# }
##############################################################################################################################################################################
class sockaddr_in( Structure ):
    _fields_ = [
          ( "sin_family", c_ushort    )         # IPv4 주소체계에서 사용하므로 항상 AF_INET으로 설정
        , ( "sin_port"  , c_uint16    )         # 포트 번호
        , ( "sin_addr"  , 4 * c_ubyte )         # IP주소를 나타내는 32비트 정수 타입
    ]

##############################################################################################################################################################################
# struct timeval
# {
#     long tv_sec ;      // 초
#     long tv_usec;      // 마이크로초
# }
##############################################################################################################################################################################
class timeval( Structure ):
    _fields_ = [
          ( 'tv_sec' , c_long )
        , ( 'tv_usec', c_long )
    ]

##############################################################################################################################################################################
# pcap 라이브러리의 주소 정보가 저장되는 pcap_addr 구조체

# struct pcap_addr {
# 	struct pcap_addr *next     ;
# 	struct sockaddr  *addr     ;        // address 
# 	struct sockaddr  *netmask  ;        // netmask
# 	struct sockaddr  *broadaddr;        // broadcast address
# 	struct sockaddr  *dstaddr  ;        // dst address 
# };
##############################################################################################################################################################################
class pcap_addr( Structure ):
    pass
pcap_addr._fields_ = [
      ( 'next'     , POINTER( pcap_addr ) )
    , ( 'addr'     , POINTER( sockaddr  ) )
    , ( 'netmask'  , POINTER( sockaddr  ) )
    , ( 'broadaddr', POINTER( sockaddr  ) )
    , ( 'dstaddr'  , POINTER( sockaddr  ) )
]

##############################################################################################################################################################################
# struct pcap_if {
# 	struct pcap_if   *next       ;      // 다음 구조체의 주소 값을 저장하기 위해 사용

# 	char             *name       ;      // 인터페이스 이름
# 	char             *description;      // 인터페이스 설명 혹은 NULL
# 	struct pcap_addr *addresses  ;
				
# 	bpf_u_int32      flags       ;      // PCAP_IF_ 인터페이스 플래그
# };
##############################################################################################################################################################################
class pcap_if( Structure ):
    pass
pcap_if._fields_ = [
      ( 'next'       , POINTER( pcap_if )   )   # NULL값이 아니라면 다음 인터페이스를 가리킨다.
    , ( 'name'       , c_char_p             )   # 인터페이스 이름
    , ( 'description', c_char_p             )   # 인터페이스 설명
    , ( 'addresses'  , POINTER( pcap_addr ) )   # 인터페이스 리스트 포인터
    , ( 'flags'      , c_int                )
]                        

##############################################################################################################################################################################
# 패킷의 헤더 정보로 패킷 다룰때 사용되는 정보

# struct pcap_pkthdr {
# 	struct timeval ts;	/* time stamp [타임 스템프] */
# 	bpf_u_int32 caplen;	/* length of portion present [현재 위치 까지의 길이] */
# 	bpf_u_int32 len;	/* length this packet (off wire) [패킷 전체의 길이] */
# };
##############################################################################################################################################################################

class pcap_pkthdr( Structure ):
    _fields_ = [
          ( 'ts'    , timeval )
        , ( 'caplen', c_int   )
        , ( 'len'   , c_int   )
    ]


PCAP_ERRBUF_SIZE = 256


pcap_if_t = pcap_if
pcap_t    = c_void_p

pcap_findalldevs          = _lib.pcap_findalldevs
pcap_findalldevs.restype  = c_int
pcap_findalldevs.argtypes = [ POINTER( POINTER( pcap_if_t ) ), c_char_p ]

pcap_freealldevs          = _lib.pcap_freealldevs
pcap_freealldevs.restype  = None
pcap_freealldevs.argtypes = [ POINTER( pcap_if_t ) ]

##############################################################################################################################################################################
# pcap_open_live:
#     첫번째 인자로 주어지는 네트웍 디바이스 device에 대한 packet capture descriptor(이하 PCD) 을 만들기 위한 함수이다.
#     패킷을 캡춰하는 실질적인 모든일은 pcap_open_live 함수를 호출해서 만들어진 PCD 를 이용해서 이루어지게 된다.
##############################################################################################################################################################################
pcap_open_live          = _lib.pcap_open_live
pcap_open_live.restype  = POINTER( pcap_t )
pcap_open_live.argtypes = [
      c_char_p
    , c_int
    , c_int
    , c_int
    , c_char_p
]

##############################################################################################################################################################################
# pcap_next_ex:
#     캡처한 패킷 데이터를 실제 가져오는 함수이다. 실제는 packet_handler라는 콜백 함수가 데이터들을 채워주는데. 이중 포인터를 인자로 받는다. 
##############################################################################################################################################################################
pcap_next_ex          = _lib.pcap_next_ex
pcap_next_ex.restype  = c_int
pcap_next_ex.argtypes = [
      POINTER( pcap_t                 )
    , POINTER( POINTER( pcap_pkthdr ) )
    , POINTER( POINTER( c_ubyte     ) )
]

pcap_sendpacket          = _lib.pcap_sendpacket
pcap_sendpacket.restype  = c_int
pcap_sendpacket.argtypes = [
      POINTER( pcap_t )
    , c_void_p
    , c_int
]

pcap_setnonblock          = _lib.pcap_setnonblock
pcap_setnonblock.restype  = c_int
pcap_setnonblock.argtypes = [
      POINTER( pcap_t )
    , c_int
    , c_char_p
]

pcap_close          = _lib.pcap_close
pcap_close.restype  = c_void_p
pcap_close.argtypes = [ POINTER( pcap_t ) ]
##############################################################################################################################################################################
# 바이너리를 string으로 변환
##############################################################################################################################################################################
def plain_str( x ):
    if isinstance( x, bytes ):
        return x.decode( ENCODING )
    
    return x if isinstance( x, str ) else str( x )

##############################################################################################################################################################################
# 바이너리가 아닐 경우 바이너리로 변환
##############################################################################################################################################################################
def chb( x ):
    if isinstance( x, bytes ):
        return x
    
    else:

        #####################################################################
        # x가 int일 경우 바이너리로 변환
        #####################################################################
        if  (     hasattr   ( x, '__int__' ) )\
        and ( not isinstance( x, int       ) ):
            return bytes( [ int( x ) ] )
        
        return bytes( [ x ] )

pcap_dict = {}

######################################################################################################################
# PCAP_ERRBUF_SIZE == 256
######################################################################################################################
err = create_string_buffer( PCAP_ERRBUF_SIZE )

######################################################################################################################
# [인터페이스 목록 포인터] // pcap_if_t은 pcap_if클래스로 만든 인스턴스
######################################################################################################################
devs = POINTER( pcap_if_t )()

######################################################################################################################
# 네트워크 디바이스의 목록을 알려주는 함수.
# alldevsp라는 구조체 포인터를 통해 목록과 특성을 알려준다.
# 성공시 0을, 실패시 -1을 반환하고, errbuf변수를 채운다.
######################################################################################################################
if pcap_findalldevs( byref( devs ), err ) < 0:
    sys.exit()      # 사용가능한 인터페이스가 없으면 프로그램을 종료.

try:
    #################################################################################################################################
    # 인터페이스 목록 파싱
    #################################################################################################################################
    p = devs
    while p:

        ###################################################################################################################
        # 인터페이스 이름을 읽을 수 있는 형태로 변환
        ###################################################################################################################
        dev_name = plain_str( p.contents.name )
        
        ###################################################################################################################
        # 인터페이스의 ip주소가 담길 필드
        ###################################################################################################################
        pcap_dict[ dev_name ] = { 'ipv4' : [] }

        ###################################################################################################################
        # 시스템에 인식된 인터페이스 리스트 포인터
        ###################################################################################################################
        a = p.contents.addresses
        while a:

            #####################################################################################################
            # sa_family( 소켓주소체계 ) == AF_INET( IPv4 )
            #####################################################################################################
            if a.contents.addr.contents.sa_family == AF_INET:

                #########################################################################################
                # pcap_addr의 addr멤버는 sockaddr을 가리키는 포인터
                #########################################################################################
                ap = a.contents.addr

                #########################################################################################
                # sockaddr_in // 소켓(인터페이스)의 네트워크주소 구조체
                # sockaddr 구조체는 소켓주소를 담는 기본적인 구조체 이지만,
                # ipv4를 이용하는 통신의 경우 sockaddr_in 구조체를 사용하는것이 더 적합.
                #
                # why? ( 
                #   sockaddr 구조체는 ip 프로토콜 외에 다른 프로토콜을 사용할 경우도 대비하여 
                #   sa_data( socket address data ) 필드에 주소와 포트번호를 함께 저장하기 때문 
                # ) 
                #########################################################################################
                val = cast( ap, POINTER( sockaddr_in ) )

                #########################################################################################
                # 인터페이스 바이너리 주소: sockaddr_in의 멤버 sin_addr에서 ip주소를 가져와 바이너리로 변환
                #########################################################################################
                if_raw_addr = b''.join( chb( x ) for x in val.contents.sin_addr[ :4 ] )

                #########################################################################################
                # 인터페이스의 바이너리 주소를 dotted decimal 형식으로 변환
                #########################################################################################
                if_addr = inet_ntoa( if_raw_addr )

                #########################################################################################
                # pcap_dict에 인터페이스별로 주소를 저장
                #########################################################################################
                pcap_dict[ dev_name ][ 'ipv4' ] += [ if_addr ]

            a = a.contents.next

        p = p.contents.next

except Exception:
    raise

##############################################################################################################################################################################
# 인터페이스 할당 메모리 해제
##############################################################################################################################################################################
finally:
    pcap_freealldevs( devs )

##############################################################################################################################################################################
# pcap 라이브러리 사용을 위한 클래스
##############################################################################################################################################################################
class PcapWrapper:
    
    def __init__( self, device, snaplen, promisc, to_ms ):

        ##################################################################################################
        # PCAP_ERRBUF_SIZE == 256
        ##################################################################################################
        self.errbuf = create_string_buffer( PCAP_ERRBUF_SIZE )

        ##################################################################################################
        # ENCODING == 'utf-8'
        ##################################################################################################
        self.iface = create_string_buffer( device.encode( ENCODING ) )

        ##################################################################################################
        # 실시간 패킷을 캡처하는 함수
        ##################################################################################################
        self.pcap = pcap_open_live(
              self.iface          # 인터페이스 지정
            , snaplen             # 패킷 버퍼사이즈
            , promisc             # 무작위모드 설정
            , to_ms               # 타임아웃밀리세컨드
            , self.errbuf         # 에러 버퍼
        )

        ##################################################################################################
        # 패킷에 대한 메타데이터가 담긴 헤더
        ##################################################################################################
        self.header = POINTER( pcap_pkthdr )()

        ##################################################################################################
        # 인터페이스를 거쳐가는 실제 데이터 ( unsigned_byte )
        ##################################################################################################
        self.pkt_data = POINTER( c_ubyte )()

        ##################################################################################################
        # 패킷 필터링 룰에 따라 결정될 구조체 pcap_compile()을 통해 도출
        ##################################################################################################
        self.bpf_program = bpf_program()

    def next( self ):

        ##################################################################################################
        # 인터페이스를 통해 오가는 패킷을 캡처링하는 함수
        ##################################################################################################
        c = pcap_next_ex( self.pcap, byref( self.header ), byref( self.pkt_data ) )
        if not c > 0:
            return
        
        ##################################################################################################
        # pcap_pkthdr의 ts필드는 timeval을 포인팅한다.
        ##################################################################################################
        ts = self.header.contents.ts.tv_sec + float( self.header.contents.ts.tv_usec ) / 1000000
        
        ##################################################################################################
        # pcap_pkthdr의 len필드를 참고하여 인터페이스를 거쳐가는 패킷을 분할한다.
        ##################################################################################################
        pkt = b''.join( chb( i ) for i in self.pkt_data[ :self.header.contents.len ] )

        return ts, pkt
    
    __next__ = next

    def setnonblock( self, i ):
        pcap_setnonblock( self.pcap, i, self.errbuf )                     

    #######################################################################################################################
    # raw 패킷을 전송한다.
    #######################################################################################################################
    def send( self, x ):
        pcap_sendpacket( self.pcap, x, len( x ) )

    #######################################################################################################################
    # 패킷을 닫고 메모리를 해제한다.
    #######################################################################################################################
    def close( self ):
        pcap_close( self.pcap )

#######################################################################################################################
# Loopback 테스트를 위한 인터페이스 이름
#######################################################################################################################
PCAP_LOOPBACK_NAME = ''

pcap_interfaces = {}

for device in pcap_dict.keys():
    
    #######################################################################################################################
    # devices has no ip
    # pcap_dict에 파싱된 인터페이스 목록에서 loopback 이라는 문자열을 포함한 인터페이스의 주소를 127.0.0.1로 지정.
    #######################################################################################################################
    if 'loopback' in device.lower():
        PCAP_LOOPBACK_NAME             = device
        pcap_interfaces[ '127.0.0.1' ] = {
              'name' : device
            , 'iface': PcapWrapper(
                  device  = device
                , snaplen = 0xffff
                , promisc = 1
                , to_ms   = 100
            )
        }

    #######################################################################################################################
    # devices has at least one ip
    #######################################################################################################################
    else:
        for ipv4 in pcap_dict[ device ][ 'ipv4' ]:
            
            if ipv4 == '127.0.0.1':
                PCAP_LOOPBACK_NAME = device

            pcap_interfaces[ ipv4 ] = {
                  'name'  : device
                , 'iface' : PcapWrapper(
                      device  = device
                    , snaplen = 0xffff
                    , promisc = 1
                    , to_ms   = 100
                )
            }

def check_pcap_installed():
    
    if WIN32:

        for pcap_dll_path in [
              environ[ 'WINDIR' ] + "\\System32\\Npcap"
            , environ[ 'WINDIR' ] + "\\System32"
        ]:
            if  ( path_exists( path_join( pcap_dll_path, 'wpcap.dll' )  ) )\
            and ( path_exists( path_join( pcap_dll_path, 'Packet.dll' ) ) ):
                return True

    else:
        
        for libpcap_so_path in [
              '/usr/lib64/libpcap.so.1'
            , '/usr/lib64/libpcap.so'
            , '/usr/lib/libpcap.so.1'
            , '/usr/lib/libpcap.so'
        ]:
            if path_exists( libpcap_so_path ):
                return True

    return False