# -*- coding: utf-8 -*-
# 
# Script : network_scanner/utils/interface.py
# Author : Hoon
# 
# ====================== Comments ======================
# 

# Python Libraries
from re        import IGNORECASE
from re        import split  as re_split
from re        import search as re_search
from ipaddress import ip_network, IPv4Address

# Module Libraries
from const.default import WIN32
from const.regex   import IP, MAC
from utils         import popen

if WIN32: mac_sep = '-'
else    : mac_sep = ':'

##########################################################################################################################################################################################
# 네트워크 인터페이스 정보, 라우팅 테이블, ARP 테이블 정보를 담는 클래스
##########################################################################################################################################################################################
class NetworkInterfaces:
    def __init__( self, logger, use_pcap=False ):
        self.logger = logger

        ######################################################################################################################################
        # 네트워크 인터페이스 정보가 담길 dict
        ######################################################################################################################################
        self.interfaces = {}

        ######################################################################################################################################
        # 라우팅 테이블 정보가 담길 list
        ######################################################################################################################################
        self.routing_table = []

        ######################################################################################################################################
        # ARP 테이블 정보가 담길 dict
        ######################################################################################################################################
        self.arp_table = {}

        ######################################################################################################################################
        # pcap.py가 파싱한 네트워크 인터페이스 객체가 담길 dict
        ######################################################################################################################################
        self.pcap_interfaces = {}

        ######################################################################################################################################
        # 인터페이스 정보를 가져오는 함수
        ######################################################################################################################################
        self.refresh_interfaces()

        ######################################################################################################################################
        # 라우팅 테이블 정보 가져오는 함수
        ######################################################################################################################################
        self.refresh_routing_table()

        ######################################################################################################################################
        # ARP 테이블 정보 가져오는 함수
        ######################################################################################################################################
        self.refresh_arp_table()
        
        ######################################################################################################################################
        # self.refresh_pcap_interfaces(): pcap 라이브러리를 이용해 네트워크 인터페이스 객체를 가져오는 함수
        ######################################################################################################################################
        if use_pcap:                           
            self.refresh_pcap_interfaces()

    ###############################################################################################################################################################################
    # 인터페이스 정보 가져오는 함수
    ###############################################################################################################################################################################
    def refresh_interfaces( self ):
        self.interfaces = {}
        
        if WIN32: command = 'ipconfig /all'
        else    : command = 'ip address'

        r = popen( command )

        iface_name = ''
        iface      = {}
        
        ############################################################################################################################################################
        # ip정보를 출력하는 명령의 표준출력 결과를 line by line으로 분리
        ############################################################################################################################################################
        lines = re_split( r'[\r\n]+', r[ 'stdout' ] )

        ############################################################################################################################################################
        # If running on Windows system
        ############################################################################################################################################################
        if WIN32:

            for line in lines:
                
                ###################################################################################################################################
                # 문자열의 시작이 공백으로 시작하지 않는 요소를 찾는다.
                ###################################################################################################################################
                if re_search( r'^[^\s]', line ):
                    
                    ###################################################################################################################
                    # 문자열에서 'adapter' 혹은 '어댑터'라는 문자열을 포함하고 ':'으로 끝나는 문자열을 찾는다. IGNORECASE는 대소문자 무시
                    ###################################################################################################################
                    if match := re_search( r'( adapter| 어댑터) (.*):$', line, IGNORECASE ):
                        
                        ###############################################################################################
                        # iface 딕셔너리에 값이 존재하면 인터페이스이름을 key로 하여 그 값을 item으로 부여
                        ###############################################################################################
                        if iface:
                            self.interfaces[ iface_name ] = iface

                        iface_name = match.group( 2 )
                        
                        ###############################################################################################
                        # parsed interface info
                        ###############################################################################################
                        iface = {
                              'description' : ''
                            , 'physical'    : ''
                            , 'ipv4'        : ''
                            , 'subnet'      : ''
                            , 'gateway'     : ''
                            , 'pcap_dict'   : None
                        }

                if iface:
                    if match := re_search( r'(Description|설명)[\. ]+:\s*(.+)$', line, IGNORECASE ):
                        iface[ 'description' ] = match.group( 2 ).strip()

                    if match := re_search( r'(Physical Address|물리적 주소)[\. ]+:\s*([A-F\d\-:]+)', line, IGNORECASE ):
                        iface[ 'physical' ] = match.group( 2 ).strip().upper()

                    if match := re_search( r'(IPv4 Address|IPv4 주소)[\. ]+:\s*([\d\.]+)', line, IGNORECASE ):
                        iface[ 'ipv4' ] = match.group( 2 ).strip()

                    if match := re_search( r'(Subnet Mask|서브넷 마스크)[\. ]+:\s*([\d\.]+)', line, IGNORECASE ):
                        iface[ 'subnet' ] = match.group( 2 ).strip()

                    if match := re_search( r'(Default Gateway|기본 게이트웨이)[\. ]+:\s*([\d\.]+)', line, IGNORECASE ):
                        iface[ 'gateway' ] = match.group( 2 ).strip()

        ############################################################################################################################################################
        # If running on Linux system
        ############################################################################################################################################################
        else:

            for line in lines:

                match = re_search( r'^\d+: (.+): ', line, IGNORECASE )
                if match:

                    if iface:
                        self.interfaces[ iface_name ] = iface
                    
                    iface_name = match.group( 1 )
                    
                    iface = {
                          'description' : ''
                        , 'physical'    : ''
                        , 'ipv4'        : ''
                        , 'subnet'      : ''
                        , 'gateway'     : ''
                        , 'pcap_dict'   : None
                    }

                match = re_search( f'inet ({IP})/(\\d+)', line, IGNORECASE )
                if match and iface:
                    iface[ 'ipv4'   ] = match.group( 1 )
                    iface[ 'subnet' ] = str( ip_network( f'0.0.0.0/{ match.group( 5 ) }' ).netmask )

        self.interfaces[ iface_name ] = iface

        ############################################################################################################################################################
        # 시스템 os가 linux일 경우 mac주소를 파싱하여 저장
        ############################################################################################################################################################
        if not WIN32:
            r = popen( 'tail /sys/class/net/*/address' )

            iface_name = ''
            lines      = re_split( r'[\r\n]+', r[ 'stdout' ] )
            for line in lines:

                match = re_search( r'/sys/class/net/(.+)/address', line, IGNORECASE )
                if match:
                    iface_name = match.group(1)

                match = re_search( f'({ MAC })', line, IGNORECASE )
                if match and iface_name:
                    self.interfaces[ iface_name ][ 'physical' ] = match.group( 1 )

    ###############################################################################################################################################################################
    # 라우팅 테이블 정보 가져오는 함수
    ###############################################################################################################################################################################
    def refresh_routing_table( self ):
        self.routing_table = []

        if WIN32: command = 'netstat -r'
        else    : command = 'ip route'

        r                = popen( command )
        ipv4_route_table = False

        lines = re_split( r'[\r\n]+', r[ 'stdout' ] )
        
        ############################################################################################################################################################
        # If running on Windows system
        ############################################################################################################################################################
        if WIN32:
            for line in lines:

                if re_search ( r'(IPv4 Route Table|IPv4 경로 테이블)', line, IGNORECASE ):
                    ipv4_route_table = True

                if re_search( r'(Persistent Routes|영구 경로)', line, IGNORECASE ):
                    ipv4_route_table = False

                if ipv4_route_table:
            
                    match = re_search( r'([\d\.]+)\s+([\d\.]+)\s+([^\s]+)\s+([\d\.]+)\s+(\d+)$', line, IGNORECASE )
                    if match:
                        network   = match.group( 1 )
                        netmask   = match.group( 2 )
                        gateway   = match.group( 3 )
                        interface = match.group( 4 )
                        metric    = match.group( 5 )
                        self.routing_table.append( {
                                  'network'   : ip_network( f"{ network }/{ netmask }" )
                                , 'gateway'   : gateway
                                , 'interface' : interface       # 인터페이스 아이피로 변경해야함
                                , 'metric'    : metric
                            }
                        )

        ############################################################################################################################################################
        # If running on Linux system
        ############################################################################################################################################################
        else:
            for line in lines:

                nw_match  = re_search( f'({ IP }/\\d+)'             , line, IGNORECASE )
                gw_match  = re_search( f'default via ({ IP })'      , line, IGNORECASE )
                match     = re_search( r'dev ([^\s]+).*metric (\d+)', line, IGNORECASE )
                src_match = re_search( r'src (\d+\.\d+\.\d+\.\d+)'  , line, IGNORECASE )
                if match:
                    gateway    = gw_match.group( 1 ) if gw_match else ''
                    iface_name = match.group( 1 )
                    metric     = match.group( 2 )
                    self.routing_table.append( {
                              'network'   : ip_network( '0.0.0.0/0' if gw_match and not nw_match else nw_match.group( 1 ) )
                            , 'gateway'   : gateway
                            , 'interface' : src_match.group( 1 ) if src_match else self.interfaces[ iface_name ][ 'ipv4' ]
                            , 'metric'    : metric
                        }
                    )
                    if gw_match:
                        self.interfaces[ iface_name ][ 'gateway' ] = gw_match.group( 1 )

        self.routing_table.sort( key=lambda a:  a[ 'interface' ]           )
        self.routing_table.sort( key=lambda a:  a[ 'metric'    ]           )
        self.routing_table.sort( key=lambda a: -a[ 'network'   ].prefixlen )

    ###############################################################################################################################################################################
    # ARP 테이블 정보 가져오는 함수
    ###############################################################################################################################################################################
    def refresh_arp_table( self ):
        self.arp_table = {}

        if WIN32: command = 'arp -a'
        else    : command = 'cat /proc/net/arp'
        
        r = popen( command )

        lines = re_split( r'[\r\n]+', r[ 'stdout' ] )
        for line in lines:
            
            ip_match  = re_search( f'({ IP  })', line, IGNORECASE )
            mac_match = re_search( f'({ MAC })', line, IGNORECASE )
            if  ( ip_match  )\
            and ( mac_match ):
                self.arp_table[ ip_match.group( 1 ) ] = mac_match.group( 1 ).upper()

    ###############################################################################################################################################################################
    # pcap 라이브러리를 이용해 네트워크 인터페이스 객체를 가져오는 함수
    # 해당 객체로 모든 패킷을 모니터링 하거나 패킷을 전송할 수 있음
    ###############################################################################################################################################################################
    def refresh_pcap_interfaces( self ):
        self.pcap_interfaces = {}

        try:
            from utils import pcap_interfaces
            self.pcap_interfaces = pcap_interfaces

        except:
            pass

        for ipv4, pcap_dict in self.pcap_interfaces.items():
            for iface in self.interfaces.values():
                
                if iface[ 'ipv4' ] == ipv4:
                    iface[ 'pcap_dict' ] = pcap_dict

    ###############################################################################################################################################################################
    # 게이트웨이, 라우팅 테이블로부터 패킷을 전송하고자 하는 대상의 정보를 가져오는 함수
    # 소켓을 이용하면 자동으로 되지만 pcap 라이브러리를 이용해 raw 패킷을 전송하기 때문에 패킷을 Layer 2부터 모두 직접 작성해야 한다.
    # 전송할 패킷에 L2 계층 목적지/출발지 정보, L3 계층 출발지 정보를 작성해야 하기 때문에 이 함수로 목적지 정보를 가져온다.
    ###############################################################################################################################################################################
    def get_dst_info( self, dst_ip ):
        dst_mac   = None
        src_mac   = None
        src_ip    = None
        pcap_dict = None

        ############################################################################################################################################################
        # 도착지ip가 루프백 주소 혹은 시스템에 존재하는 nic의 ip 주소인 경우
        ############################################################################################################################################################
        if ( dst_ip == '127.0.0.1'                                       )\
        or ( dst_ip in [ i[ 'ipv4' ] for i in self.interfaces.values() ] ):
            
            ##############################################################################################################
            # 출발지/도착지 mac을 모두 00:00:00:00:00:00으로 설정한다.
            ##############################################################################################################
            src_mac = dst_mac = mac_sep.join( [ '00' ] * 6 )
            
            ##############################################################################################################
            # 출발지ip를 도착지ip로 설정한다.
            ##############################################################################################################
            src_ip  = dst_ip

            ##############################################################################################################
            # pcap을 이용하여 파싱한 nic 정보중에 루프백 주소가 있는 경우
            # 루프백인터페이스의 정보를 pcap_dict에 추가한다.
            ##############################################################################################################
            if '127.0.0.1' in self.pcap_interfaces:
                pcap_dict = self.pcap_interfaces[ '127.0.0.1' ]

        ############################################################################################################################################################
        # dst_ip가 자신이 아닌경우
        ############################################################################################################################################################
        else:
            interface_ip = None
            for route in self.routing_table:

                ##############################################################################################################
                # dst_ip가 라우팅테이블에 존재하는지 검사
                ##############################################################################################################
                if IPv4Address( dst_ip ) in route[ 'network' ]:
                    interface_ip = route[ 'interface' ]
                    break

            if interface_ip == None:
                self.logger.warning( f'cannot get routing info: { dst_ip }' )

            for interface in self.interfaces.values():
                
                if interface[ 'ipv4' ] == interface_ip:
                    if IPv4Address( dst_ip ) in ip_network( f"{ interface[ 'ipv4' ] }/{ interface[ 'subnet' ] }", strict=False ):
                        
                        ##############################################################################################################
                        # internal network
                        ##############################################################################################################
                        if dst_ip in self.arp_table:
                            dst_mac = self.arp_table[ dst_ip ]
                    
                    else:

                        ##############################################################################################################
                        # external network
                        ##############################################################################################################
                        if interface[ 'gateway' ] in self.arp_table:
                            dst_mac = self.arp_table[ interface[ 'gateway' ] ]

                    src_mac   = interface[ 'physical'  ]
                    src_ip    = interface[ 'ipv4'      ]
                    pcap_dict = interface[ 'pcap_dict' ]
                    break

        return dst_mac, src_mac, src_ip, pcap_dict